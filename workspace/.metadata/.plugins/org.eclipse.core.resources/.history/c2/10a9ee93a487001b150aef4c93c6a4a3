package kr.or.ddit.enumpkg;

import kr.or.ddit.vo.CalculateVO;

public enum OperatorType {
   PLUS('+', new RealOperator() {
      public double operate(double left, double right) {
         return left + right;
      }
   }), 
   MINUS('-', new RealOperator() {
      public double operate(double left, double right) {
         return left - right;
      }
   }),
   MULTIPLY('*', new RealOperator() {
      public double operate(double left, double right) {
         return left * right;
      }
   }),
   DIVIDE('/',(left, right)->{
	   return left/right;
   });
   
	//인터페이스로 형태안내
	@FunctionalInterface
   private interface RealOperator{
      public double operate(double left, double right);
   }

   private OperatorType(char sign, RealOperator realOperator) {
      this.sign = sign;
      this.realOperator = realOperator;
   }
   
   
   private RealOperator realOperator;
   private char sign;   //상수가 결정이 되야지만 연산자의 기호도 결정이됨 그렇기떄문에 미리 값을 할당할 수 없음   
                  // 이데이터를 넘길수 있는 방법은 생서자임
   public char getSign() {
      return sign;
   }
   
   public double operate(double left, double right) {
      return realOperator.operate(left, right);
   }
   
   private static final String EXPRPTRN = "%f %s %f = %f";
   
   public String expression(CalculateVO vo) {
      return String.format(EXPRPTRN, vo.getLeft(), sign, vo.getRight(), operate(vo.getLeft(), vo.getRight()));
   }
   
   
}

